<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: KinematicsHierachy.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: KinematicsHierachy.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { KinematicsAnimationGroup } from './KinematicsAnimation.js';
import { KinematicsComponent } from './KinematicsComponent.js';
import { componentType } from './KinematicsComponent.js';
import { KinematicsManager } from './KinematicsManager.js';
import { KinematicsUtility } from './KinematicsUtility.js';

/** Hierachy class for Kinematics  
* Kinematics Manager
*
* Simple Kinematics Engine for HOOPS Communicator
 
*/
export class KinematicsHierachy {

    constructor() {

        this._templateId = null;
        this._highestId = 0;
        this._nodeid = undefined;

        this._componentNodeidHash = [];
        this._componentHash = [];

        this._ikTip = new Communicator.Point3(0, 0, 0);   
        this._ikThreshold = 1;
        this._ikSpeed = 100;
        this._ikSamplingDistance = 0.1;
        this._ikSamplingDistanceTranslation = 1;
        this._ikLearningRate = 0.1;
        this._interval = null;

        this._targetPoint = new Communicator.Point3(0, 0, 0);
       
        
        this._rootComponent = this.createComponent(null,[],true);
        this._rootComponent.setType(componentType.fixed);
        
        this._tipComponent = null;

        this._targetAnchorPosition = null;
        this._targetAnchorNode = null;       
        
        this._dirty = false;
    }


    getComponentById(id)
    {
        let res = this._componentHash[id];
        if (res != undefined)
            return  res;
        else
            return null;
    }


    getTemplateId()
    {
        return this._templateId;
    }

    setDirty(isDirty)
    {
        this._dirty = true;
    }

    getDirty()
    {
        return this._dirty;
    }

    async updateComponents()
    {
        await this._rootComponent._updateComponentsFromReferenceRecursive(this._rootComponent);
    }
    setNodeId(nodeid)
    {
        this._nodeid = nodeid;        
    }

    setIkTip(tip)
    {
        this._ikTip = tip;
    }

    getIkTip()
    {
        return this._ikTip;
    }

    setIkThreshold(ikThreshold)
    {
        this._ikThreshold = ikThreshold;
    }

    getIkThreshold()
    {
        return this._ikThreshold;
    }

    setIkSpeed(ikSpeed)
    {
        this._ikSpeed = ikSpeed;
    }
    
    getIkSpeed()
    {
        return this._ikSpeed;
    }

    
    setIkSamplingDistance(ikSamplingDistance)
    {
        this._ikSamplingDistance = ikSamplingDistance;
    }
    
    
    getIkSamplingDistance()
    {
        return this._ikSamplingDistance;
    }

     
    setIkSamplingDistanceTranslation(ikSamplingDistanceTranslation)
    {
        this._ikSamplingDistanceTranslation = ikSamplingDistanceTranslation;
    }

    getIkSamplingDistanceTranslation()
    {
        return this._ikSamplingDistanceTranslation;
    }

       
    setIkLearningRate(ikLearningRate)
    {
        this._ikLearningRate = ikLearningRate;
    }


    getIkLearningRate()
    {
        return this._ikLearningRate;
    }
    

    getComponentHash()
    {
        return this._componentHash;
    }


    getRootComponent()
    {
        return this._rootComponent;
    }
    getComponentById(id)
    {
        return this._componentHash[id];
    }

    isIKActive()
    {
        if (this._interval)
            return true;
        else
            return false;
    }


    stopIK()
    {
        if (this._interval) {
            clear_interval(this._interval);
            this._interval = null;
        }
    }

    startIKFromHandle() {

        if (!this._interval) {
            let _this = this;
            let handleOperator = KinematicsManager.viewer.operatorManager.getOperator(Communicator.OperatorId.Handle);
            this._interval = set_interval(async function () {
                let targetpoint = handleOperator.getPosition();
                if (targetpoint || _this._targetAnchorPosition) {
                    if (_this._targetAnchorPosition) {
                        let m = KinematicsManager.viewer.model.getNodeNetMatrix(_this._targetAnchorNode);
                        _this._targetPoint = m.transform(_this._targetAnchorPosition);
                    }
                    else {
                        let m = KinematicsManager.viewer.model.getNodeMatrix(KinematicsManager.handleNode);
                        _this._targetPoint = m.transform(new Communicator.Point3(0, 0, 0));
                    }
                    for (let i = 0; i &lt; _this._ikSpeed; i++) {
                        let dis = _this.distanceFromIKTarget();
                        if (dis > _this._ikThreshold) {
                            await _this._inverseKinematics();
                        }                       
                    }
                }

            }, 1);
        }
    }

    generateTemplate()
    {
        if (!this._templateId)
        {
            this._templateId = KinematicsUtility.generateGUID();
            let template = this.toJson();
            KM.KinematicsManager.addTemplate(template);           
        }
        else
        {
            let template = KM.KinematicsManager.toJson(this);
            KM.KinematicsManager.updateTemplate(template);
        }        
    }
    

    insertIKHandle() {
        let handleOperator = KinematicsManager.viewer.operatorManager.getOperator(Communicator.OperatorId.Handle);
        handleOperator.removeHandles();            
        handleOperator.addHandles([KinematicsManager.handleNode], this._targetPoint);
        KinematicsManager.viewer.model.setNodesVisibility([KinematicsManager.handleNode], true);
        handleOperator.showHandles();
    }

    setIKHandleToTip(insertHandle)
    {
        let mat = this.getReferenceNodeNetMatrix(this._tipComponent);
        let _ikTip = mat.transform(this._ikTip);

        mat = new Communicator.Matrix();
        mat.setTranslationComponent(_ikTip.x, _ikTip.y, _ikTip.z);
        this._targetPoint = _ikTip.copy();
        KinematicsManager.viewer.model.setNodeMatrix(KinematicsManager.handleNode, mat);
        if (insertHandle)
            this.insertIKHandle();
    }

    setTipToHandlePosition()
    {
       
        let handleOperator = KinematicsManager.viewer.operatorManager.getOperator(Communicator.OperatorId.Handle);
        let pos = handleOperator.getPosition();
     
        this._ikTip = this._tipComponent.transformPointToComponentSpace(pos);
    }

    setTargetAnchorToHandlePosition()
    {
       
        let handleOperator = KinematicsManager.viewer.operatorManager.getOperator(Communicator.OperatorId.Handle);
        let pos = handleOperator.getPosition();
        let selections = KinematicsManager.viewer.selectionManager.getResults();
        let nodeid = selections[0].getNodeId();

        let resmatrix = Communicator.Matrix.inverse(KinematicsManager.viewer.model.getNodeNetMatrix(nodeid));
        this._targetAnchorPosition = resmatrix.transform(pos);    
        this._targetAnchorNode = nodeid;
    }

    
    removeAnimationFromComponents(_templateId)
    {
        this._rootComponent.removeAnimationRecursive(_templateId);
    }


    toJson() {
        let def = { version: 1.0,_ikTip: this._ikTip.toJson(),_templateId: this._templateId,_ikSamplingDistance: this._ikSamplingDistance, _ikSamplingDistanceTranslation: this._ikSamplingDistanceTranslation, _ikLearningRate: this._ikLearningRate, _ikThreshold: this._ikThreshold, _ikSpeed: this._ikSpeed, 
            _targetAnchorNode:this._targetAnchorNode };
        if (this._targetAnchorPosition)            
            def._targetAnchorPosition = this._targetAnchorPosition.toJson();
        def.components = this._rootComponent.toJson();

        let animhash = [];
        let anims = [];
        this._rootComponent.animToJson(animhash);
        for (let i in animhash)
        {
            let atemplate = KinematicsManager.getAnimationTemplate(i);
            if (atemplate != undefined)
            {
                atemplate._templateId = i;
                anims.push(atemplate);            
            }
        }
        def.animations = anims;


        def.animationGroups = [];
        for (let i=0;i&lt;KinematicsManager._animationGroups.length;i++)
        {
            let group = KinematicsManager._animationGroups[i];
            if (group.hierachy == this)
            {
                def.animationGroups.push(group.toJson());
            }
        }

        return def;
    }

    fromJson(def) {
        this._highestId = 0;
        this._ikTip = Communicator.Point3.fromJson(def._ikTip);
        this._ikThreshold = def._ikThreshold;
        this._ikSpeed = def._ikSpeed;
        this._ikSamplingDistance = def._ikSamplingDistance;
        this._ikSamplingDistanceTranslation = def._ikSamplingDistanceTranslation;
        this._ikLearningRate = def._ikLearningRate;      
        this._targetAnchorNode = def._targetAnchorNode;
        this._templateId = def._templateId;
        if (def._targetAnchorPosition)
            this._targetAnchorPosition = Communicator.Point3.fromJson(def._targetAnchorPosition);

        let component = new KinematicsComponent(null,this);
        component.fromJson(def.components, def.version);
        this._rootComponent = component;

        while (true)
        {        
            if (component.getChildren().length==0) 
            {
                this._tipComponent = component;
                break;
            }                
            component = component.getChildren()[0];
        }      
        
        for (let i in this._componentHash)
        {
            let component = this._componentHash[i];
            if (component.getType() == componentType.prismaticTriangle || component.getType() == componentType.prismaticAggregate || component.getType() == componentType.mate)
            {
                component.setExtraComponent1(this._componentHash[component.getExtraComponent1()]);
                component.setExtraComponent2(this._componentHash[component.getExtraComponent2()]);
            }
            if (component.getType() == componentType.revoluteSlide)
            {
                component.setExtraComponent1(this._componentHash[component.getExtraComponent1()]);
            }
            else if (component.getType() == componentType.pistonController)
            {
                component.setExtraComponent1(this._componentHash[component.getExtraComponent1()]);
            }
            else if (component.getType() == componentType.mapped)
            {
                component._mappedTargetComponent = this._componentHash[component.getMappedTargetComponent()];
            }
        }

        if (def.animations != undefined) {
            for (let i = 0; i &lt; def.animations.length; i++) {
                KinematicsManager.addAnimationTemplateFromJson(def.animations[i]._templateId, def.animations[i]);

            }
        }

        if (def.animationGroups != undefined) {
            for (let i = 0; i &lt; def.animationGroups.length; i++) {
                let group = new KinematicsAnimationGroup(this);
                group.fromJson(def.animationGroups[i]);
                KinematicsManager.addAnimationGroup(group);
            }
        }

        return def;
    }



    distanceFromIKTarget() {
        let matrix = this.getReferenceNodeNetMatrix(this._tipComponent);      
        let temp = matrix.transform(this._ikTip);
        let res = Communicator.Point3.subtract(this._targetPoint, temp);
        return res.length();
    }

    resetComponents() {

        let component = this._rootComponent;
        while (true) {
     
            component.reset();
            if (component.getChildren().length == 0)
                break;
            component = component.getChildren()[0];                
        }
        if (this._interval) {
            clear_interval(this._interval);
            this._interval = null;
        }
    }

    createComponent(parentcomponent, nodeids, isReferenceIn, infront) {

        let isReference = true;
        if (isReferenceIn != undefined &amp;&amp; isReferenceIn == false)
            isReference = false;

        let component = new KinematicsComponent(parentcomponent, this);
        this._componentHash[component.getId()] = component;
        component.initialize(nodeids, isReference);
        if (parentcomponent == null)
            this._rootComponent = component;
        else {
            if (!infront)
                parentcomponent.getChildren().push(component);
            else
                parentcomponent.getChildren().unshift(component);
        }

        this._tipComponent = this._findTipComponent();
        for (let i = 0; i &lt; nodeids.length; i++)
            this._componentNodeidHash[nodeids[i]] = component;

        return component;
    }

    createComponentFromSelection(parentcomponent,isReference, infront)
    {          
        let nodeids = [];
        let selections = KinematicsManager.viewer.selectionManager.getResults();
        for (let i=0;i&lt;selections.length;i++)
            nodeids.push(selections[i].getNodeId());
         
        let newcomponent = this.createComponent(parentcomponent,nodeids, isReference, infront);
      
        newcomponent.setParametersFromHandle();
        return newcomponent;      
    }

    async rebuildComponentTree()
    {
        KinematicsManager.viewer.model.deleteNode(this._rootComponent.getNodeId());
        this._rebuildComponentTreeRecursive(this._rootComponent);        
    }



    applyToModel(nodeid)
    {
        this._componentNodeidHash = [];
        let childnode = KinematicsManager.viewer.model.getNodeChildren(nodeid)[0];
        let startmatrix;
        if (nodeid == KinematicsManager.viewer.model.getRootNode() || nodeid == undefined)
            startmatrix = new Communicator.Matrix();
        else
            startmatrix = KinematicsManager.viewer.model.getNodeMatrix(nodeid);

        this._applyToModelRecursive(this._rootComponent, KinematicsManager.viewer.model.getNodeIdOffset(childnode), startmatrix);
    }

    

    getReferenceNodeNetMatrix(incomponent) 
    { 
        return KinematicsManager.viewer.model.getNodeNetMatrix(incomponent.getNodeId());
    }


    _applyToModelRecursive(component, offset, startmatrix)
    {
     
        this._componentNodeidHash[component.getNodeId()] = component;

        let temp = startmatrix.transform(Communicator.Point3.add(component.getCenter(),component.getAxis()));
        component.setCenter(startmatrix.transform(component.getCenter()));
        component.setAxis(Communicator.Point3.subtract(temp,component.getCenter()).normalize());
        
        component._parentMatrix = Communicator.Matrix.multiply(component.getParentMatrix(), startmatrix);
        if (component.fixedAxis)
            component.fixedAxis = startmatrix.transform(component.fixedAxis);
         
        let referenceNodes = component.getReferenceNodes();
        for (let i=0;i&lt;referenceNodes.length;i++)
        {

            referenceNodes[i].nodeid = offset + referenceNodes[i].nodeid;            
            referenceNodes[i].matrix = Communicator.Matrix.multiply(referenceNodes[i].matrix,startmatrix);

            this._componentNodeidHash[referenceNodes[i].nodeid] = component;

        }
      
        if (component.getChildren().length > 0)
        {
            for (let j=0;j&lt;component.getChildren().length;j++)
                this._applyToModelRecursive(component.getChildren()[j], offset, startmatrix);
        }
        
    }

    
    _findTipComponent()
    {
        let component = this._rootComponent;
        while (true) {
              
            if (component.getChildren().length == 0)
                break;
            component = component.getChildren()[0];                
        }
        return component;
    
    }

    _rebuildComponentTreeRecursive(component)
    {
        if (!component.getParent())
            component.setNodeId(KinematicsManager.viewer.model.createNode(KinematicsManager.viewer.model.getRootNode(), "_rootComponent"));
         else
            component.setNodeId(KinematicsManager.viewer.model.createNode(component.getParent().getNodeId(), "component"));
        if (component.getChildren().length > 0)
        {
            for (let j=0;j&lt;component.getChildren().length;j++)
                this._rebuildComponentTreeRecursive(component.getChildren()[j]);
        }
        
    }

    async _inverseKinematics() {

        let component = this._rootComponent;
        while (true)
        {
            if (component.getType() != componentType.fixed &amp;&amp; component.fixedAxis == null &amp;&amp; component.getType() != componentType.pistonController &amp;&amp; component.getType() != componentType.prismaticAggregate)
            {
                let gradient = await component.calculateGradient();
                await component.update(gradient);       
            }
            if (component.getType() == componentType.prismaticAggregate)
            {
                let gradient = await component.getExtraComponent1().calculateGradient();
                await component.getExtraComponent1().update(gradient);       
                gradient = await component.getExtraComponent2().calculateGradient();
                await component.getExtraComponent2().update(gradient);                       
            }
            if (component.getChildren().length==0 || (component.getType() == componentType.fixed &amp;&amp; component != this._rootComponent))
                break;                
            component = component.getChildren()[0];
        } 
        await this._rootComponent.updateComponentsFromReference();

    }
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="KinematicsHierachy.html">KinematicsHierachy</a></li><li><a href="KinematicsManager.html">KinematicsManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri Apr 29 2022 09:52:39 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
