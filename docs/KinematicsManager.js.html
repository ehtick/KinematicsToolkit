<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: KinematicsManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: KinematicsManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { KinematicsAnimation } from './KinematicsAnimation.js';
import { KinematicsHierachy } from './KinematicsHierachy.js';
import { KinematicsUtility } from './KinematicsUtility.js';
import { HandlePlacementOperator } from './HandlePlacementOperator.js';

/** This static class provides access to all Kinematics Related Functionality. */
export class KinematicsManager {

     
     /**
     * Initializes the KinematicsManager  
     * Should only be called once.
     * @param  {object} viewer - WebViewer Object
     */
    static initialize(viewer) {
        KinematicsManager.viewer = viewer;
           
        KinematicsManager._hierachies = [];
        KinematicsManager._hierachyTemplates = [];
        KinematicsManager._animationTemplates = [];
        KinematicsManager._animations = [];
        KinematicsManager._animationGroups = [];
        KinematicsManager.handlePlacementOperator = null;
    }

    /**
     * Initializes Handle Placement Operator
     */
    static setupHandleOperator()
    {
        KinematicsManager.handlePlacementOperator = new HandlePlacementOperator(KinematicsManager.viewer);
        let myOperatorHandle = KinematicsManager.viewer.operatorManager.registerCustomOperator(KinematicsManager.handlePlacementOperator);
        KinematicsManager.viewer.operatorManager.push(myOperatorHandle);

        KinematicsManager.handleNode = KinematicsManager.viewer.model.createNode(KinematicsManager.viewer.model.getRootNode(), "handlenode");
    }

     /**
     * Retrieves Hierachy Template Array
     * @return {number} Hierachy Template Object
     */   
    static getHierachyTemplates() {
        return KinematicsManager._hierachyTemplates;        
    }

    static getHierachies() {
        return KinematicsManager._hierachies;        
    }

    static getAnimationTemplates() {
        return KinematicsManager._animationTemplates;        
    }

    /**
     * Returns an animationtemplate by its id
     * @param  {string} animationtemplateid - UUID of animation template
     * @return {number} Sum of a and b
     */
    static getAnimationTemplate(animationtemplateid) {
        return KinematicsManager._animationTemplates[animationtemplateid];        
    }
 /**
     * Returns all animation groups  
     * @return {number} Sum of a and b
     */
    static getAnimationGroups() {
        return KinematicsManager._animationGroups;        
    }


    static getHierachyByIndex(i) {
        return KinematicsManager._hierachies[i];        
    }

    static getJointFromNodeId(nodeid) {
        for (let i = 0; i &lt; KinematicsManager._hierachies.length; i++) {

            let res = KinematicsManager._hierachies[i]._jointNodeidHash[nodeid];
            if (res != undefined)
                return res;
        }
        return null;
    }


    static getHierachyFromNodeId(nodeid) {
        if (nodeid != undefined &amp;&amp; nodeid != KinematicsManager.viewer.model.getRootNode())
        {
            while (1)
            {
                if (KinematicsManager.viewer.model.getNodeParent(nodeid) == KinematicsManager.viewer.model.getRootNode())
                    break;
                else
                    nodeid = KinematicsManager.viewer.model.getNodeParent(nodeid);

            }
        }
        for (let i=0;i&lt;KinematicsManager._hierachies.length;i++) {
            if (KinematicsManager._hierachies[i].nodeid == nodeid)
                return i;
        }
        return undefined;
    }

    static applyToModel(_templateId, nodeid) {
        let hierachy = new KinematicsHierachy();
        hierachy.fromJson(KinematicsManager._hierachyTemplates[_templateId]);
        hierachy.applyToModel(nodeid);
        hierachy.setNodeId(nodeid);
        KinematicsManager._hierachies.push(hierachy);
        return hierachy;
    }


    static createHierachy(def) {

        let hierachy = new KinematicsHierachy();
        this._hierachies.push(hierachy);
        return hierachy;

    }

    static addTemplate(def)
    {
        KinematicsManager._hierachyTemplates[def._templateId] = def;   
        return def._templateId;     
    }

    static updateTemplate(def)
    {
        KinematicsManager._hierachyTemplates[def._templateId] = def;        
    }

    static getTemplate(_templateId)
    {
        return KinematicsManager._hierachyTemplates[_templateId];
    }


    static updateAnimationTemplate(animationtemplateid, name, anime) {
        let def = KinematicsManager._animationTemplates[animationtemplateid];
        def.name = name;        
        def.anime = anime;        
        KinematicsManager._animationTemplates[animationtemplateid] = JSON.parse(JSON.stringify(def));
    }
  

    
    static addAnimationTemplate(name,anime,easeintime,_ikSpeed)
    {
        let def = {name:name,anime:anime};
        def = JSON.parse(JSON.stringify(def));
        let animationId = KinematicsUtility.generateGUID();
        KinematicsManager._animationTemplates[animationId] = def;
        return animationId;

    }

    static addAnimationTemplateFromJson(_templateId,def)
    {
        let def2 = JSON.parse(JSON.stringify(def));       
        KinematicsManager._animationTemplates[_templateId] = def2;

    }

    static startAnimation(joint,anime)
    {
        let animation = new KinematicsAnimation("test",joint,JSON.parse(JSON.stringify(anime)));

        KinematicsManager._animations.push(animation);
        if (KinematicsManager._animations.length == 1)
            window.requestAnimationFrame(KinematicsManager._doAnimation);
    }

    
    static stopAnimation(joint)
    {
        for (let i=0;i&lt;KinematicsManager._animations.length;i++)
        {
            if (joint == undefined || KinematicsManager._animations[i].getJoint() == joint)
                KinematicsManager._animations[i].setDone(true);
        }

    }
    static changeAnimationSpeed(joint,newspeed)
    {
        for (let i=0;i&lt;KinematicsManager._animations.length;i++)
        {
            if (KinematicsManager._animations[i].joint == joint)
                KinematicsManager._animations[i].changeAnimationSpeed(newspeed);
        }
    }

    static _doAnimation(timestamp) {

        if (KinematicsManager._animations.length > 0) {
            for (let i=0;i&lt;KinematicsManager._hierachies.length;i++)
            {
                KinematicsManager._hierachies[i].setDirty(false);
            }
            
            for (let i = 0; i &lt; KinematicsManager._animations.length; i++) {
                KinematicsManager._animations[i].getJoint().getHierachy().setDirty(true);
                KinematicsManager._animations[i].update(timestamp);
                if (KinematicsManager._animations[i].getDone()) {
                    KinematicsManager._animations.splice(i, 1);
                    i--;
                }
            }

            for (let i=0;i&lt;KinematicsManager._hierachies.length;i++)
            {
                if (KinematicsManager._hierachies[i].getDirty())                                                 
                    KinematicsManager._hierachies[i].updateJoints();
            }

            window.requestAnimationFrame(KinematicsManager._doAnimation);
        }
    }

    static deleteAnimationTemplate(_templateId)
    {
        delete KinematicsManager._animationTemplates[_templateId];
        for (let i = 0; i &lt; KinematicsManager._hierachies.length; i++) {
            KinematicsManager._hierachies[i].removeAnimationFromJoints(_templateId);
        }

    }

    static addAnimationGroup(animagroup)
    {
        KinematicsManager._animationGroups.push(animagroup);
        return KinematicsManager._animationGroups.length-1;
    }

    static startAnimationGroup(groupid)
    {
        KinematicsManager._animationGroups[groupid].play();    
    }
}


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="KinematicsHierachy.html">KinematicsHierachy</a></li><li><a href="KinematicsManager.html">KinematicsManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri Apr 29 2022 09:52:39 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
